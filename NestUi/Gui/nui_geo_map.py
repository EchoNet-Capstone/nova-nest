import os

import json
from PySide6.QtWidgets import QVBoxLayout, QWidget
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtWebEngineCore import QWebEnginePage
from PySide6.QtWebChannel import QWebChannel
from PySide6.QtCore import QObject, Slot, Signal
from folium import Element
from jinja2 import Template
from ..Utils.nest_map import *

class WebEnginePage(QWebEnginePage):
    """ Custom WebEnginePage to capture JavaScript console messages in PyQt. """
    def __init__(self, parent):
        super().__init__(parent)
        self.parent = parent            

    def javaScriptConsoleMessage(self, level, msg, line, sourceID):
        """ Capture console messages from JavaScript and send them to PyQt. """
        print(f"JavaScript Console [{level}]: {msg}")  # Debugging log
        if "coordinates" in msg:
            self.parent.handleConsoleMessage(msg)  # Send to PyQt handler


class MapBridge(QObject):
    markerClicked = Signal(str)  # ✅ Signal for JS communication

    @Slot(str)
    def recvMessage(self, message):
        print(f"Message from web page: {message}")
        self.markerClicked.emit(message)  # ✅ Emit to UI

class NestGeoMapWidget(QWidget):
    """ PyQt Widget for displaying a Folium map inside a QWebEngineView and receiving marker clicks. """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()
        self.setLayout(layout)

        # Create QWebEngineView and custom WebEnginePage
        self.web_view = QWebEngineView()
        self.web_page = WebEnginePage(self)
        self.web_view.setPage(self.web_page)

        # Set up QWebChannel and register our bridge
        self.channel = QWebChannel()
        self.bridge = MapBridge()
        self.channel.registerObject("mapbridge", self.bridge)
        self.web_view.page().setWebChannel(self.channel)

        # Load the map HTML generated by Folium
        map_html = get_html_map(True)
        self.web_view.setHtml(map_html)

        # Connect the markerClicked signal to a slot
        self.bridge.markerClicked.connect(self.on_marker_click)

        layout.addWidget(self.web_view)


    def on_marker_click(self, buoy_id):
        """ Slot called when a marker is clicked in JavaScript. """
        print(f"✅ Buoy Marker Clicked: {buoy_id}")
        self.label.setText(f"Marker clicked: {buoy_id}")
        

    def handleConsoleMessage(self, msg):
        """ Extracts coordinates from JavaScript console log and updates PyQt UI. """
        data = json.loads(msg)
        lat = data['coordinates']['lat']
        lng = data['coordinates']['lng']
        coords_text = f"Latitude: {lat}, Longitude: {lng}"
        self.label.setText(coords_text)  # Update label in PyQt
        print(f"✅ Coordinates received: {coords_text}")
   
def add_external_js(map_object, js_file_path):
    """
    Reads an external JavaScript file, renders it as a Jinja2 template with the
    map instance variable, and injects the resulting script into the map's header.
    """
    if os.path.exists(js_file_path):
        with open(js_file_path, "r", encoding="utf-8") as f:
            js_raw = f.read()
        template = Template(js_raw)
        rendered_js = template.render(map_instance=map_object.get_name())
        script_element = Element(f"<script>{rendered_js}</script>")
        map_object.get_root().header.add_child(script_element)
        print(f"✅ Injected external JavaScript with macro: {js_file_path}")
    else:
        print(f"❌ ERROR: JavaScript file not found at {js_file_path}")
    return map_object

def get_html_map(use_random_data=False):
    """Generates an HTML map using Folium and adds external JavaScript for click events."""
    folium_map = setup_map()

    # Inject external JavaScript without overwriting existing plugin JS.
    js_path = "NestUi/Utils/js/mapInteractions.js"  # Adjust path as needed.
    js_qweb = "NestUi/Utils/js/qwebchannel.js"
    folium_map = add_external_js(folium_map, js_qweb)
    folium_map = add_external_js(folium_map, js_path)

    if use_random_data:
        # Generate random buoys (returns a list of Folium Marker objects)
        markers = generate_random_buoys(num_buoys=10)
        for marker in markers:
            marker.add_to(folium_map)
    else:
        # Fetch actual buoys from API
        gdf = get_buoys()
        add_events_to_map(folium_map, gdf)  # Existing function for API markers

    # Save HTML for debugging
    map_html = folium_map._repr_html_()
    file_name = "clickable_map.html"
    with open(file_name, "w", encoding="utf-8") as file:
        file.write(map_html)
    print(f"✅ Clickable map saved to {os.path.abspath(file_name)}")

    return map_html
